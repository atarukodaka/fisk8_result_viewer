// locals: competition, category, segment, category_summaries
//   optional: category_results (only when 'category' specified)
/              segment_scores (only when 'segment' specified)

- content_for :title do
  | competition: 
  = [competition.name, category, segment].reject(&:blank?).join(' / ')


- case result_type
- when :category
  - breadcrumb :competition_category, competition, category
- when :segment
  - breadcrumb :competition_segment, competition, category, segment
- else
  - breadcrumb :competition, competition

////////////////////////////////////////////////////////////////
h2 Competition Info

= competition_info.render(self, locals: { decorate: true })

////////////////////////////////////////////////////////////////
/h2 Category / Segment

/= category_segments.render(self, settings: { paging: false }, locals: {decorate: true})

////////////////////////////////////////////////////////////////
h2 Category / Segment
table.table.table-striped.table-hover.table-condensed
  tr
    th Category
    - competition.category_results.pluck(:category).uniq.each do |category|
      td= link_to_competition(competition, category: category)
  - if result_type == :category
  tr
    th Segment
    - competition.scores.where(category: category).pluck(:segment).uniq.each do |s|
      td 
        = link_to_competition(competition, category: category, segment: s)
        = link_to_pdf(competition.scores.first.try(:result_pdf))


////////////////////////////////////////////////////////////////
- if result_type != :none
  - section_id = [category, segment].compact.join('-')
  h2 id="#{section_id}"
    = (result_type == :category) ? "Category Result of #{category}" : "Segment Result of #{category}/#{segment}"

  = result_datatable.render(self, settings: {paging: false }, locals: { decorate: true})
    
